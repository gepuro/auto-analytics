"""
Independent FastAPI Server for Auto Analytics Report Display

This server is completely decoupled from the AI agent and only serves
HTML reports generated by the agent. It monitors the reports directory
and provides a web interface for browsing and viewing reports.
"""

import os
import asyncio
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import HTMLResponse, FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
import aiofiles
import uvicorn


class ReportDisplayServer:
    """
    Independent FastAPI server for displaying HTML reports.
    
    This server only handles report display and does not generate reports.
    Reports are generated by the separate AI agent system.
    """
    
    def __init__(
        self, 
        reports_dir: Optional[str] = None, 
        template_dir: Optional[str] = None,
        static_dir: Optional[str] = None
    ):
        """
        Initialize the report display server.
        
        Args:
            reports_dir: Directory containing HTML reports (default: ../reports)
            template_dir: Directory containing Jinja2 templates
            static_dir: Directory containing static files
        """
        # Set up directories
        if reports_dir is None:
            # Default to reports directory in workspace root
            reports_dir = Path(__file__).parent.parent / "reports"
        self.reports_dir = Path(reports_dir)
        self.reports_dir.mkdir(exist_ok=True)
        
        if template_dir is None:
            template_dir = Path(__file__).parent / "templates"
        self.template_dir = Path(template_dir)
        
        if static_dir is None:
            static_dir = Path(__file__).parent / "static"
        self.static_dir = Path(static_dir)
        self.static_dir.mkdir(exist_ok=True)
        
        # Initialize FastAPI app
        self.app = self._create_app()
    
    def _create_app(self) -> FastAPI:
        """Create and configure FastAPI application."""
        app = FastAPI(
            title="Auto Analytics Report Display Server",
            description="Independent FastAPI server for displaying AI-generated analysis reports",
            version="1.0.0",
            docs_url="/api/docs",
            redoc_url="/api/redoc"
        )
        
        # Add CORS middleware
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # Set up templates
        templates = Jinja2Templates(directory=str(self.template_dir))
        
        # Mount static files
        if self.static_dir.exists():
            app.mount("/static", StaticFiles(directory=str(self.static_dir)), name="static")
        
        # Register routes
        self._register_routes(app, templates)
        
        return app
    
    def _register_routes(self, app: FastAPI, templates: Jinja2Templates):
        """Register all API routes."""
        
        @app.get("/", response_class=HTMLResponse)
        async def root(request: Request):
            """Serve the main reports listing page."""
            try:
                reports = await self._get_reports_list()
                return templates.TemplateResponse(
                    "report_list.html", 
                    {
                        "request": request,
                        "reports": reports,
                        "total_reports": len(reports),
                        "server_info": {
                            "reports_dir": str(self.reports_dir),
                            "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        }
                    }
                )
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to load reports: {str(e)}")
        
        @app.get("/api/reports", response_model=List[Dict[str, Any]])
        async def get_reports_api():
            """Get list of available reports as JSON."""
            try:
                reports = await self._get_reports_list()
                return JSONResponse(content={"reports": reports, "count": len(reports)})
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to fetch reports: {str(e)}")
        
        @app.get("/reports/{filename}", response_class=HTMLResponse)
        async def serve_report(filename: str):
            """Serve individual HTML report for display in browser."""
            try:
                # Security: validate filename
                if ".." in filename or "/" in filename or "\\" in filename:
                    raise HTTPException(status_code=400, detail="Invalid filename")
                
                file_path = self.reports_dir / filename
                
                if not file_path.exists():
                    raise HTTPException(status_code=404, detail="Report not found")
                
                if not file_path.suffix.lower() == ".html":
                    raise HTTPException(status_code=400, detail="Only HTML files are supported")
                
                # Read HTML content and return as HTMLResponse for browser display
                async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                    html_content = await f.read()
                
                return HTMLResponse(content=html_content)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to serve report: {str(e)}")
        
        @app.get("/reports/{filename}/download")
        async def download_report(filename: str):
            """Download HTML report as file."""
            try:
                # Security: validate filename
                if ".." in filename or "/" in filename or "\\" in filename:
                    raise HTTPException(status_code=400, detail="Invalid filename")
                
                file_path = self.reports_dir / filename
                
                if not file_path.exists():
                    raise HTTPException(status_code=404, detail="Report not found")
                
                if not file_path.suffix.lower() == ".html":
                    raise HTTPException(status_code=400, detail="Only HTML files are supported")
                
                # Return as file download
                return FileResponse(
                    path=str(file_path),
                    media_type="text/html",
                    filename=filename,
                    headers={"Content-Disposition": f"attachment; filename={filename}"}
                )
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to download report: {str(e)}")
        
        @app.get("/api/reports/{filename}/info")
        async def get_report_info(filename: str):
            """Get metadata for a specific report."""
            try:
                if ".." in filename or "/" in filename or "\\" in filename:
                    raise HTTPException(status_code=400, detail="Invalid filename")
                
                file_path = self.reports_dir / filename
                
                if not file_path.exists():
                    raise HTTPException(status_code=404, detail="Report not found")
                
                info = await self._get_report_info(file_path)
                return JSONResponse(content=info)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to get report info: {str(e)}")
        
        @app.get("/api/health")
        async def health_check():
            """Health check endpoint."""
            return JSONResponse(content={
                "status": "healthy",
                "service": "report-display-server",
                "timestamp": datetime.now().isoformat(),
                "reports_dir": str(self.reports_dir),
                "total_reports": len(list(self.reports_dir.glob("*.html"))),
                "version": "1.0.0"
            })
        
        @app.delete("/api/reports/{filename}")
        async def delete_report(filename: str):
            """Delete a report file."""
            try:
                if ".." in filename or "/" in filename or "\\" in filename:
                    raise HTTPException(status_code=400, detail="Invalid filename")
                
                file_path = self.reports_dir / filename
                
                if not file_path.exists():
                    raise HTTPException(status_code=404, detail="Report not found")
                
                file_path.unlink()
                return JSONResponse(content={"message": f"Report {filename} deleted successfully"})
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to delete report: {str(e)}")
        
        @app.post("/api/refresh")
        async def refresh_reports():
            """Refresh the reports list (useful for polling)."""
            try:
                reports = await self._get_reports_list()
                return JSONResponse(content={
                    "message": "Reports refreshed successfully",
                    "count": len(reports),
                    "timestamp": datetime.now().isoformat()
                })
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Failed to refresh reports: {str(e)}")
    
    async def _get_reports_list(self) -> List[Dict[str, Any]]:
        """Get list of available HTML reports with metadata."""
        reports = []
        
        for file_path in self.reports_dir.glob("*.html"):
            try:
                info = await self._get_report_info(file_path)
                reports.append(info)
            except Exception:
                # Skip files that can't be processed
                continue
        
        # Sort by modification time (newest first)
        reports.sort(key=lambda x: x["modified_timestamp"], reverse=True)
        
        return reports
    
    async def _get_report_info(self, file_path: Path) -> Dict[str, Any]:
        """Get metadata for a single report file."""
        stat = file_path.stat()
        
        # Try to extract title from HTML content
        title = await self._extract_title_from_html(file_path)
        
        return {
            "filename": file_path.name,
            "title": title or file_path.stem.replace("_", " ").title(),
            "size": stat.st_size,
            "size_formatted": self._format_file_size(stat.st_size),
            "modified": datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S"),
            "modified_timestamp": stat.st_mtime,
            "url": f"/reports/{file_path.name}",
            "api_url": f"/api/reports/{file_path.name}/info",
            "delete_url": f"/api/reports/{file_path.name}"
        }
    
    async def _extract_title_from_html(self, file_path: Path) -> Optional[str]:
        """Extract title from HTML file."""
        try:
            async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                # Read first 2KB to find title
                content = await f.read(2048)
            
            # Simple title extraction
            if "<title>" in content and "</title>" in content:
                start = content.find("<title>") + 7
                end = content.find("</title>", start)
                if start > 6 and end > start:
                    return content[start:end].strip()
            
            # Look for h1 headers
            import re
            h1_match = re.search(r'<h1[^>]*>([^<]+)</h1>', content, re.IGNORECASE)
            if h1_match:
                return h1_match.group(1).strip()
            
            return None
        except Exception:
            return None
    
    def _format_file_size(self, size_bytes: int) -> str:
        """Format file size in human-readable format."""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        else:
            return f"{size_bytes / (1024 * 1024):.1f} MB"


# Create global server instance
server = ReportDisplayServer()
app = server.app


def main():
    """Main entry point for running the server."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Auto Analytics Report Display Server")
    parser.add_argument("--host", default="localhost", help="Host to bind to")
    parser.add_argument("--port", type=int, default=9000, help="Port to bind to")
    parser.add_argument("--reports-dir", help="Directory containing reports")
    parser.add_argument("--reload", action="store_true", help="Enable auto-reload")
    
    args = parser.parse_args()
    
    # Update reports directory if specified
    if args.reports_dir:
        server.reports_dir = Path(args.reports_dir)
        server.reports_dir.mkdir(exist_ok=True)
    
    print(f"ðŸš€ Starting Report Display Server at http://{args.host}:{args.port}")
    print(f"ðŸ“ Serving reports from: {server.reports_dir}")
    print(f"ðŸ“Š API docs available at: http://{args.host}:{args.port}/api/docs")
    
    uvicorn.run(
        "main:app",
        host=args.host,
        port=args.port,
        reload=args.reload,
        log_level="info"
    )


if __name__ == "__main__":
    main()